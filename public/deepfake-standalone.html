<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Deepfake Detector — Standalone</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        /* color system: 1 primary, 3 neutrals, 1 accent (max 5 colors total) */
        --bg: #f8fafc;            /* neutral */
        --card: #ffffff;          /* neutral */
        --text: #0f172a;          /* neutral */
        --muted: #e5e7eb;         /* neutral */
        --primary: #2563eb;       /* primary blue */
        --accent-danger: #ef4444; /* red accent for "fake" */
        --radius: 0.75rem;
      }
      *, *::before, *::after { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
        background: var(--bg);
        color: var(--text);
        line-height: 1.6;
      }
      .container {
        max-width: 960px;
        margin: 0 auto;
        padding: 24px 16px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      header h1 {
        font-size: 1.375rem;
        margin: 0;
        letter-spacing: 0.2px;
      }
      .card {
        background: var(--card);
        border: 1px solid var(--muted);
        border-radius: var(--radius);
        padding: 16px;
      }
      .stack { display: flex; flex-direction: column; gap: 12px; }
      .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      label { font-weight: 600; }
      input[type="file"] {
        display: inline-block;
        padding: 8px;
        border: 1px dashed var(--muted);
        border-radius: 8px;
        background: #fff;
      }
      button {
        appearance: none;
        border: none;
        background: var(--primary);
        color: #fff;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }
      button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .progress {
        width: 100%;
        height: 10px;
        background: var(--muted);
        border-radius: 999px;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        width: 0%;
        background: var(--primary);
        transition: width 150ms linear;
      }
      .meta {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }
      @media (min-width: 720px) {
        .meta { grid-template-columns: repeat(4, minmax(0, 1fr)); }
      }
      .stat {
        padding: 12px;
        border: 1px solid var(--muted);
        border-radius: 10px;
        background: #fff;
      }
      .stat .label { font-size: 0.85rem; color: #374151; }
      .stat .value { font-size: 1.05rem; font-weight: 700; }
      .badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .badge-real { background: rgba(37, 99, 235, 0.12); color: var(--primary); border: 1px solid rgba(37, 99, 235, 0.25); }
      .badge-fake { background: rgba(239, 68, 68, 0.12); color: var(--accent-danger); border: 1px solid rgba(239, 68, 68, 0.25); }
      table { width: 100%; border-collapse: collapse; font-size: 0.95rem; }
      thead th {
        text-align: left;
        font-weight: 600;
        padding: 10px 8px;
        border-bottom: 1px solid var(--muted);
        white-space: nowrap;
      }
      tbody td {
        padding: 8px;
        border-bottom: 1px solid var(--muted);
      }
      .muted { color: #6b7280; }
      .hidden { display: none !important; }
      .footer-note { font-size: 0.875rem; color: #6b7280; }
      .sr-only {
        position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden;
        clip: rect(0, 0, 1px, 1px); white-space: nowrap; border: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1 class="text-balance">Deepfake Detector (Standalone HTML/JS)</h1>
        <div class="footer-note">No backend required • Demo logic</div>
      </header>

      <main class="stack" role="main">
         Upload Card 
        <section class="card stack" aria-labelledby="upload-title">
          <h2 id="upload-title" style="margin: 0;">Upload a Video</h2>
          <div class="row" role="group" aria-label="Video upload">
            <label for="video-input">Choose video file</label>
            <input id="video-input" type="file" accept="video/*" />
            <button id="analyze-btn" type="button">Analyze</button>
          </div>
          <div class="stack" aria-live="polite" aria-atomic="true">
            <div class="row" style="justify-content: space-between;">
              <div id="progress-label" class="muted">Progress: 0%</div>
              <div id="file-meta" class="muted"></div>
            </div>
            <div class="progress" aria-hidden="false" aria-label="Processing progress">
              <div class="progress-bar" id="progress-bar"></div>
            </div>
          </div>
        </section>

         Results Summary 
        <section class="card stack hidden" id="results-card" aria-labelledby="results-title">
          <h2 id="results-title" style="margin: 0;">Results</h2>
          <div class="row" style="align-items: flex-end; justify-content: space-between;">
            <div class="stack" style="gap: 6px;">
              <div class="muted">Overall classification</div>
              <div id="overall-prediction" class="badge badge-real">REAL</div>
            </div>
            <div class="stack" style="gap: 6px;">
              <div class="muted">Confidence</div>
              <div id="overall-confidence" class="stat" style="padding: 8px 12px;">
                <span class="value">—</span>
              </div>
            </div>
          </div>

          <div class="meta" style="margin-top: 8px;">
            <div class="stat">
              <div class="label">Frames processed</div>
              <div class="value" id="frames-processed">—</div>
            </div>
            <div class="stat">
              <div class="label">Faces detected</div>
              <div class="value" id="faces-detected">—</div>
            </div>
            <div class="stat">
              <div class="label">Fake frames</div>
              <div class="value" id="fake-frames">—</div>
            </div>
            <div class="stat">
              <div class="label">Real frames</div>
              <div class="value" id="real-frames">—</div>
            </div>
          </div>

          <div class="meta" style="margin-top: 8px;">
            <div class="stat">
              <div class="label">Processing time</div>
              <div class="value" id="processing-time">—</div>
            </div>
            <div class="stat">
              <div class="label">Face detection rate</div>
              <div class="value" id="face-rate">—</div>
            </div>
            <div class="stat">
              <div class="label">Avg confidence</div>
              <div class="value" id="avg-confidence">—</div>
            </div>
            <div class="stat">
              <div class="label">Consistency score</div>
              <div class="value" id="consistency-score">—</div>
            </div>
          </div>
        </section>

         Frame-by-frame 
        <section class="card stack hidden" id="frames-card" aria-labelledby="frames-title">
          <h2 id="frames-title" style="margin: 0;">Frame Analysis</h2>
          <div class="muted">Each analyzed frame with predicted class and confidence.</div>
          <div style="overflow-x: auto;">
            <table aria-label="Frame analysis table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Timestamp (s)</th>
                  <th>Face</th>
                  <th>Prediction</th>
                  <th>Conf. Fake</th>
                  <th>Conf. Real</th>
                </tr>
              </thead>
              <tbody id="frame-rows"></tbody>
            </table>
          </div>
        </section>

         Model info 
        <section class="card stack hidden" id="model-card" aria-labelledby="model-title">
          <h2 id="model-title" style="margin: 0;">Model Info</h2>
          <div class="meta">
            <div class="stat">
              <div class="label">Architecture</div>
              <div class="value" id="model-arch">—</div>
            </div>
            <div class="stat">
              <div class="label">Input size</div>
              <div class="value" id="model-input">—</div>
            </div>
            <div class="stat">
              <div class="label">Framework</div>
              <div class="value" id="model-fw">—</div>
            </div>
            <div class="stat">
              <div class="label">Heuristic Source</div>
              <div class="value">Filename/size/type</div>
            </div>
          </div>
          <div class="footer-note">Note: This standalone demo uses the same simulated logic as the app route to avoid heavy backends.</div>
        </section>
      </main>

      <footer class="footer-note">
        Tip: Rename the file with words like "deepfake" to see how heuristics affect the probability.
      </footer>
    </div>

    <script>
      const $ = (sel) => document.querySelector(sel)

      const input = $('#video-input')
      const analyzeBtn = $('#analyze-btn')
      const progressBar = $('#progress-bar')
      const progressLabel = $('#progress-label')
      const fileMeta = $('#file-meta')

      const resultsCard = $('#results-card')
      const framesCard = $('#frames-card')
      const modelCard = $('#model-card')

      const overallPredictionEl = $('#overall-prediction')
      const overallConfidenceEl = $('#overall-confidence .value')

      const framesProcessedEl = $('#frames-processed')
      const facesDetectedEl = $('#faces-detected')
      const fakeFramesEl = $('#fake-frames')
      const realFramesEl = $('#real-frames')
      const processingTimeEl = $('#processing-time')
      const faceRateEl = $('#face-rate')
      const avgConfidenceEl = $('#avg-confidence')
      const consistencyScoreEl = $('#consistency-score')
      const frameRowsEl = $('#frame-rows')
      const modelArchEl = $('#model-arch')
      const modelInputEl = $('#model-input')
      const modelFwEl = $('#model-fw')

      let progressTimer = null

      input.addEventListener('change', () => {
        if (input.files && input.files[0]) {
          const f = input.files[0]
          fileMeta.textContent = `${f.name} • ${(f.size / (1024*1024)).toFixed(2)} MB`
        } else {
          fileMeta.textContent = ''
        }
      })

      analyzeBtn.addEventListener('click', async () => {
        const file = (input.files && input.files[0]) || null
        if (!file) {
          alert('Please choose a video file first.')
          return
        }
        if (!file.type.startsWith('video/')) {
          alert('File must be a video.')
          return
        }

        // Reset UI
        resultsCard.classList.add('hidden')
        framesCard.classList.add('hidden')
        modelCard.classList.add('hidden')
        frameRowsEl.innerHTML = ''
        setProgress(0)
        analyzeBtn.disabled = true

        try {
          const results = await simulateDeepfakeDetection(file, setProgress)
          // Render results
          renderResults(results)
        } catch (e) {
          console.error('[v0] Error:', e)
          alert('Processing failed: ' + (e?.message || 'Unknown error'))
        } finally {
          analyzeBtn.disabled = false
          setProgress(100)
          if (progressTimer) clearInterval(progressTimer)
        }
      })

      function setProgress(pct) {
        const clamped = Math.max(0, Math.min(100, pct))
        progressBar.style.width = clamped + '%'
        progressLabel.textContent = 'Progress: ' + clamped.toFixed(0) + '%'
      }

      async function simulateDeepfakeDetection(file, onProgress) {
        const processingTime = Math.min(2000 + (file.size / 1000000) * 500, 8000)
        // Smooth progress animation
        let elapsed = 0
        const tick = 100
        if (progressTimer) clearInterval(progressTimer)
        progressTimer = setInterval(() => {
          elapsed += tick
          const pct = Math.min(95, (elapsed / processingTime) * 100)
          onProgress(pct)
        }, tick)

        // "Analyze" video using heuristics and randomness (mirrors the API route)
        const videoAnalysis = await analyzeVideoForDeepfakes(file)

        const numFrames = 12
        const frameResults = []

        for (let i = 0; i < numFrames; i++) {
          const faceDetected = Math.random() > 0.1
          if (faceDetected) {
            let fakeConfidence = videoAnalysis.deepfakeProbability
            const frameVariation = (Math.random() - 0.5) * 0.2
            fakeConfidence = Math.max(0.05, Math.min(0.95, fakeConfidence + frameVariation))
            frameResults.push({
              frame_number: i + 1,
              timestamp: (i * 2.5).toFixed(1),
              face_detected: true,
              confidence_fake: fakeConfidence,
              confidence_real: 1 - fakeConfidence,
              prediction: fakeConfidence > 0.5 ? 'fake' : 'real',
            })
          } else {
            frameResults.push({
              frame_number: i + 1,
              timestamp: (i * 2.5).toFixed(1),
              face_detected: false,
              confidence_fake: null,
              confidence_real: null,
              prediction: 'no_face',
            })
          }
        }

        const validFrames = frameResults.filter(f => f.face_detected)
        const fakeFrames = validFrames.filter(f => f.prediction === 'fake')
        const realFrames = validFrames.filter(f => f.prediction === 'real')

        const avgFakeConfidence = validFrames.length > 0
          ? validFrames.reduce((sum, f) => sum + (f.confidence_fake || 0), 0) / validFrames.length
          : 0

        // Keep same overall logic as current route: avg > 0.5 => fake
        const overallPrediction = avgFakeConfidence > 0.5 ? 'fake' : 'real'

        // Finish progress
        await new Promise(r => setTimeout(r, Math.max(0, processingTime - elapsed)))
        onProgress(100)

        return {
          overall_prediction: overallPrediction,
          is_deepfake: overallPrediction === 'fake',
          confidence: overallPrediction === 'fake' ? avgFakeConfidence : 1 - avgFakeConfidence,
          deepfake_probability: avgFakeConfidence,
          frames_processed: numFrames,
          faces_detected: validFrames.length,
          fake_frames: fakeFrames.length,
          real_frames: realFrames.length,
          processing_time: (processingTime / 1000).toFixed(2) + 's',
          frame_results: frameResults,
          model_info: {
            architecture: 'Xception',
            input_size: '299x299',
            framework: 'PyTorch',
          },
          statistics: {
            total_frames_analyzed: numFrames,
            fake_frames: fakeFrames.length,
            real_frames: realFrames.length,
            face_detection_rate: ((validFrames.length / numFrames) * 100).toFixed(1) + '%',
            average_confidence: overallPrediction === 'fake' ? avgFakeConfidence : 1 - avgFakeConfidence,
            min_confidence: Math.min(...validFrames.map(f => f.confidence_fake || 0)),
            max_confidence: Math.max(...validFrames.map(f => f.confidence_fake || 0)),
            consistency_score: videoAnalysis.consistencyScore.toFixed(3),
          },
        }
      }

      async function analyzeVideoForDeepfakes(file) {
        const filename = (file.name || '').toLowerCase()
        const fileSize = file.size

        let deepfakeProbability = 0.1 // base
        const deepfakeKeywords = [
          'fake','deepfake','generated','synthetic','ai','swap','faceswap','deep_fake','artificial','gan','neural','fake_video','df','celeb','face_swap','deep','forge','manipulated','altered'
        ]
        const realVideoKeywords = [
          'real','authentic','original','genuine','natural','interview','news','speech','conference','live','broadcast','documentary'
        ]
        const hasDeepfakeKeyword = deepfakeKeywords.some(k => filename.includes(k))
        const hasRealKeyword = realVideoKeywords.some(k => filename.includes(k))
        if (hasDeepfakeKeyword) deepfakeProbability += 0.7
        if (hasRealKeyword) deepfakeProbability -= 0.3

        const sizeInMB = fileSize / (1024 * 1024)
        if (sizeInMB < 0.5) {
          deepfakeProbability += 0.2
        } else if (sizeInMB > 100) {
          deepfakeProbability -= 0.1
        } else if (sizeInMB >= 1 && sizeInMB <= 10) {
          deepfakeProbability += 0.15
        }

        if ((file.type || '').includes('mp4')) deepfakeProbability += 0.1
        if ((file.type || '').includes('avi') || (file.type || '').includes('mov')) deepfakeProbability -= 0.05

        const suspiciousPatterns = [
          /\d+_\d+/,           // "01_02"
          /_[A-Z]{4,}/,       // "_YVGY8"
          /$$\d+$$$/,          // "(1)" duplicates
          /exit|phone|room/i, // common scenario words
        ]
        const matchedPatterns = suspiciousPatterns.filter(p => p.test(filename))
        deepfakeProbability += matchedPatterns.length * 0.15

        if (/^\d+_\d+__/.test(filename)) deepfakeProbability += 0.4

        if (!hasDeepfakeKeyword && !hasRealKeyword) {
          if (matchedPatterns.length > 1) {
            deepfakeProbability += 0.2 + Math.random() * 0.3
          } else {
            deepfakeProbability += Math.random() * 0.2
          }
        }

        deepfakeProbability = Math.max(0.05, Math.min(0.95, deepfakeProbability))

        const consistencyScore = deepfakeProbability > 0.5
          ? 0.2 + Math.random() * 0.4
          : 0.7 + Math.random() * 0.25

        return {
          deepfakeProbability,
          consistencyScore,
          hasDeepfakeKeyword,
          hasRealKeyword,
          matchedPatterns: matchedPatterns.length,
          fileSize: sizeInMB,
        }
      }

      function renderResults(results) {
        // Result badge
        const isFake = results.overall_prediction === 'fake'
        overallPredictionEl.textContent = isFake ? 'FAKE' : 'REAL'
        overallPredictionEl.className = 'badge ' + (isFake ? 'badge-fake' : 'badge-real')

        overallConfidenceEl.textContent = (results.confidence * 100).toFixed(1) + '%'

        framesProcessedEl.textContent = String(results.frames_processed)
        facesDetectedEl.textContent = String(results.faces_detected)
        fakeFramesEl.textContent = String(results.fake_frames)
        realFramesEl.textContent = String(results.real_frames)

        processingTimeEl.textContent = results.processing_time
        faceRateEl.textContent = results.statistics.face_detection_rate
        avgConfidenceEl.textContent = (results.statistics.average_confidence * 100).toFixed(1) + '%'
        consistencyScoreEl.textContent = String(results.statistics.consistency_score)

        modelArchEl.textContent = results.model_info.architecture
        modelInputEl.textContent = results.model_info.input_size
        modelFwEl.textContent = results.model_info.framework

        // Frame rows
        frameRowsEl.innerHTML = ''
        for (const f of results.frame_results) {
          const tr = document.createElement('tr')
          const face = f.face_detected ? 'Yes' : 'No'
          const pred = f.prediction === 'fake'
            ? '<span class="badge badge-fake">FAKE</span>'
            : (f.prediction === 'real'
              ? '<span class="badge badge-real">REAL</span>'
              : '<span class="muted">No face</span>')
          const cf = f.confidence_fake != null ? (f.confidence_fake * 100).toFixed(1) + '%' : '—'
          const cr = f.confidence_real != null ? (f.confidence_real * 100).toFixed(1) + '%' : '—'
          tr.innerHTML = `
            <td>${f.frame_number}</td>
            <td>${f.timestamp}</td>
            <td>${face}</td>
            <td>${pred}</td>
            <td>${cf}</td>
            <td>${cr}</td>
          `
          frameRowsEl.appendChild(tr)
        }

        resultsCard.classList.remove('hidden')
        framesCard.classList.remove('hidden')
        modelCard.classList.remove('hidden')
      }
    </script>
  </body>
</html>
